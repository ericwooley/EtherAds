/* tslint:disable */
import fs from 'fs'
import { join } from 'path'
import chalk from 'chalk'
const BUILD_DIR = join(__dirname, '../build/')
const directories = fs.readdirSync(BUILD_DIR)

interface ISolUnit {
  name: string
  type: string
  components?: any
}
interface IMethod {
  constant: boolean
  inputs: ISolUnit[]
  name: string
  outputs: ISolUnit[]
  payable: boolean
  stateMutability: 'nonpayable' | 'pure' | 'view' | 'payable'
  type: 'function' | 'event' | 'constructor' | 'fallback'
  anonymous: boolean
}

function getInterfaceFromDir(dir: string) {
  const contractInterface = JSON.parse(
    fs.readFileSync(join(BUILD_DIR, dir, 'interface.json')).toString()
  )
  return { contractInterface, dir }
}

function SolMethodToTSInterface(className: string) {
  return function(mi: IMethod) {
    const inputString = mi.inputs
      ? mi.inputs
          .map(i => `${i.name || 'idx'}: ${solcTypeToTSType(i.type)}`)
          .join(', ')
      : ''
    switch (mi.type) {
      case 'constructor':
        return ``
      case 'function':
        const returnType = solcTypeToTSType(
          (mi.outputs[0] || { type: '' }).type
        )
        return `
      ${mi.name}: (${inputString}) => {
      call: (options?: {from: string, gas?: string, gasPrice?: string}, callBack?: (error: Error|void, result: ${returnType}) => any) => Promise<${returnType}>,
      send: (options?: {from: string, gas?: string, gasPrice?: string, value?: string|number|BigNumber}, callBack?: (error: Error|void, result: ${returnType}) => any) => DeployEventEmitter<IReceipt>&Promise<IReceipt>,
      estimateGas: (options?: {from: string, gas?: string, gasPrice?: string, value?: string|number|BigNumber}, callBack?: (error: Error|void, result: ${returnType}) => any) => Promise<BigNumber>,
      encodeABI: () => string
    }
`;
      case 'fallback':
        return ``
      default:
        console.log(chalk.red('unhandled case'), mi.type)
        return ``
    }
  }
}

function solcTypeToTSType(t: string) {
  let type = ''
  const words = t.match(/([a-zA-Z0-9]+)(.*)/)

  if (!words) {
    return 'null'
  }
  if (words[1].indexOf('int') !== -1) {
    type = 'BigNumber|number|string'
  } else {
    switch (words[1]) {
      case 'address':
      case 'string':
        type = 'string'
        break
      case 'bool':
        type = 'boolean'
        break
      case 'ufixed':
      case 'fixed':
        type = 'BigNumber|number|string'
        break
      default:
        console.log(words[1], '=>', 'null')
        type = 'null'
    }
  }
  return type + words[2]
}

const eventInterfaceToType = (def: ISolUnit[]) =>
  `{ ${def
    .map(({ name, type }) => `${name}: ${solcTypeToTSType(type)}`)
    .join(", ")} }`;


directories
  .map(getInterfaceFromDir)
  .map(
    ({
      contractInterface,
      dir
    }: {
      contractInterface: IMethod[]
      dir: string
    }) => {
      const contractName = dir.split('-')[1]
      const methods = contractInterface
        .filter(potentialMethod => potentialMethod.type === 'function')
        .map(SolMethodToTSInterface(contractName))
        .map(method => method.trim())
        .filter(method => !!method)
      const constructor = contractInterface.find(i => i.type === 'constructor')
      let constructorArgsTypes = constructor
        ? constructor.inputs.map(i => solcTypeToTSType(i.type))
        : []

      const events = contractInterface.filter(
        potentialMethod => potentialMethod.type === 'event'
      )

      const contractTSInterface = `/* tslint:disable */
/**
 * This file was auto generated by generate-types, written by https://github.com/ericwooley.
 * Edit at your own risk.
 **/

import BigNumber from 'bignumber.js'

type DeployEventEmitter<T> = Promise<T>&{ on: (event: string, callBack: (...args: any[]) => any) => DeployEventEmitter<T>}

type IDeployPromise<T> = {
  send: (options?: {
        from?: string,
        gas?: number|string,
        gasPrice?: number|string,
        value?: number|string
      }, onError?: (error: Error, transactionHash: string) => any) => DeployEventEmitter<T>
}

type DeployArgs = {
  data: string,
  arguments: [${constructorArgsTypes.join(", ")}]
}

type I${contractName}Events = ${[...events.map(e => `"${e.name}"`), `"allEvents"`].join(" | ")};

interface Event {
  returnValues: Object,
  raw: {
      data: string,
      topics: string[],
  },
  event: string,
  signature: string,
  logIndex: number,
  transactionIndex: number,
  transactionHash: string,
  blockHash: string,
  blockNumber: number,
  address: string
}

interface IEventOptions {
  filter?: Object,
  fromBlock?: number,
  topics?: string[]
}


interface IReceiptEvent<T> {
    returnValues: T,
    raw: {
        data: string,
        topics: string[]
    },
    event: string,
    signature: string,
    logIndex: number,
    transactionIndex: number,
    transactionHash: string,
    blockHash: string,
    blockNumber: number,
    address: string
}
export interface IReceipt {
  "transactionHash": string,
  "transactionIndex": number,
  "blockHash": string,
  "blockNumber": number,
  "contractAddress": string,
  "cumulativeGasUsed": number,
  "gasUsed": number,
  "events": {
      ${events
        .map(
          e =>
            `${e.name}: IReceiptEvent<${eventInterfaceToType(
              e.inputs
            )}>|IReceiptEvent<${eventInterfaceToType(e.inputs)}>[]`
        )
        .join(",\n      ")}
  }
}

type EventCallBack = (error: Error|void, event: Event) => any

type EventEmitter = {
  on: (type: "data"|"changed"|"error", callBack: (event:Event|Error) => any) => EventEmitter
}
export interface I${contractName}Definition {
  clone: () => I${contractName},
  deploy: (options?: DeployArgs) => IDeployPromise<I${contractName}>
}
export interface I${contractName} {
  options: {
    address: string,
    jsonInterface: Object[],
    data: string,
    from: string,
    gasPrice: string,
    gas: BigNumber
  },
  methods: {
    ${methods.join(",\n    ")}
  },
  once: (eventName: I${contractName}Events, options: IEventOptions, callBack: EventCallBack) => void,
  getPastEvents: (eventName: I${contractName}Events, options: IEventOptions, callBack?: EventCallBack) => Promise<Event[]>,
  events: {
    ${events
      .map(
        e =>
          `${
            e.name
          }: (options: IEventOptions, callBack?: IEventOptions) => EventEmitter`
      )
      .join(",\n    ")}
  }
}`;
      return {
        contractInterface,
        dir,
        contractTSInterface
      }
    }
  )
  .forEach(processContract => {
    const outFile = join(BUILD_DIR, processContract.dir, 'index.ts')
    fs.writeFileSync(outFile, processContract.contractTSInterface)
    console.log('success:', processContract.dir, '-->', outFile)
  })
